{"version":3,"file":"AsyncAggregateEvaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/AsyncAggregateEvaluator.ts"],"names":[],"mappings":";;;AAGA,qDAAkD;AAClD,sFAAmF;AAEnF,MAAa,uBAAwB,SAAQ,+CAAsB;IAGjE,YAAmB,IAAiC,EAAE,OAAgC,EAAE,UAAoB;QAC1G,KAAK,CAAC,IAAI,EAAE,+BAAc,CAAC,eAAe,CAAC,OAAO,IAAI,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;QACvE,IAAI,CAAC,SAAS,GAAG,IAAI,+BAAc,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAC9D,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;IAC7B,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,QAAsB;QACrC,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,OAAO;SACR;QACD,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,IAAI,CAAC,kBAAmB,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;SAChD;aAAM;YACL,IAAI;gBACF,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;gBAC1D,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,aAAa,EAAE;oBACpC,OAAO;iBACR;gBACD,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;aAChC;YAAC,OAAO,KAAc,EAAE;gBACvB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aACvB;SACF;IACH,CAAC;IAES,SAAS,CAAC,GAAY;QAC9B,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,MAAM,GAAG,CAAC;SACX;aAAM;YACL,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;SAC3B;IACH,CAAC;CACF;AAnCD,0DAmCC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { IAsyncEvaluatorContext } from './AsyncEvaluator';\nimport { AsyncEvaluator } from './AsyncEvaluator';\nimport { BaseAggregateEvaluator } from './evaluatorHelpers/BaseAggregateEvaluator';\n\nexport class AsyncAggregateEvaluator extends BaseAggregateEvaluator {\n  private readonly evaluator: AsyncEvaluator;\n\n  public constructor(expr: Algebra.AggregateExpression, context?: IAsyncEvaluatorContext, throwError?: boolean) {\n    super(expr, AsyncEvaluator.completeContext(context || {}), throwError);\n    this.evaluator = new AsyncEvaluator(expr.expression, context);\n    this.errorOccurred = false;\n  }\n\n  public async put(bindings: RDF.Bindings): Promise<void> {\n    if (this.errorOccurred) {\n      return;\n    }\n    if (this.isWildcard) {\n      this.wildcardAggregator!.putBindings(bindings);\n    } else {\n      try {\n        const startTerm = await this.evaluator.evaluate(bindings);\n        if (!startTerm || this.errorOccurred) {\n          return;\n        }\n        this.aggregator.put(startTerm);\n      } catch (error: unknown) {\n        this.safeThrow(error);\n      }\n    }\n  }\n\n  protected safeThrow(err: unknown): void {\n    if (this.throwError) {\n      throw err;\n    } else {\n      this.errorOccurred = true;\n    }\n  }\n}\n"]}
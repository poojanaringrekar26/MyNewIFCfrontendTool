{"version":3,"file":"BaseAggregateEvaluator.js","sourceRoot":"","sources":["../../../../lib/evaluators/evaluatorHelpers/BaseAggregateEvaluator.ts"],"names":[],"mappings":";;;AACA,qDAA0C;AAC1C,mDAAgD;AAChD,6DAA0D;AAC1D,uFAAoF;AAEpF,yCAAyC;AAGzC,MAAsB,sBAAsB;IAQ1C,YAAsB,IAAiC,EACrD,aAAqC,EAAE,UAAoB;QANnD,eAAU,GAAG,KAAK,CAAC;QACnB,eAAU,GAAG,KAAK,CAAC;QAEnB,kBAAa,GAAG,KAAK,CAAC;QAI9B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,IAAI,uBAAU,CAAC,IAAI,EAAE,IAAI,yBAAW,CAAe,IAAI,CAAC,UAAU,CAAC,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC,CAAC;QAC5G,IAAI,CAAC,UAAU,GAAG,UAAU,IAAI,KAAK,CAAC;QACtC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,KAAK,yBAAO,CAAC,eAAe,CAAC,QAAQ,CAAC;QACtF,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,IAAI,CAAC,kBAAkB,GAAG,IAAI,iDAAuB,CAAC,IAAI,CAAC,CAAC;SAC7D;IACH,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,UAAU,CAAC,IAAiC,EAAE,UAAU,GAAG,KAAK;QAC5E,IAAI,GAAyB,CAAC;QAC9B,IAAI,IAAI,CAAC,UAAU,CAAC,cAAc,KAAK,yBAAO,CAAC,eAAe,CAAC,QAAQ,EAAE;YACvE,GAAG,GAAG,iDAAuB,CAAC,UAAU,EAAE,CAAC;SAC5C;aAAM;YACL,GAAG,GAAG,uBAAU,CAAC,UAAU,CAAC,yBAAW,CAAe,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;SACzE;QACD,IAAI,GAAG,KAAK,SAAS,IAAI,UAAU,EAAE;YACnC,MAAM,IAAI,GAAG,CAAC,mBAAmB,EAAE,CAAC;SACrC;QACD,OAAO,GAAG,CAAC;IACb,CAAC;IAEM,MAAM;QACX,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,OAAO,SAAS,CAAC;SAClB;QACD,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,OAAO,IAAI,CAAC,kBAAmB,CAAC,MAAM,EAAE,CAAC;SAC1C;QACD,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;IAClC,CAAC;CAaF;AA7DD,wDA6DC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { Algebra } from 'sparqlalgebrajs';\nimport { aggregators } from '../../aggregators';\nimport { Aggregator } from '../../aggregators/Aggregator';\nimport { WildcardCountAggregator } from '../../aggregators/WildcardCountAggregator';\nimport type { SetFunction } from '../../util/Consts';\nimport * as Err from '../../util/Errors';\nimport type { ICompleteSharedContext } from './BaseExpressionEvaluator';\n\nexport abstract class BaseAggregateEvaluator {\n  protected expression: Algebra.AggregateExpression;\n  protected aggregator: Aggregator;\n  protected throwError = false;\n  protected isWildcard = false;\n  protected wildcardAggregator: WildcardCountAggregator | undefined;\n  protected errorOccurred = false;\n\n  protected constructor(expr: Algebra.AggregateExpression,\n    sharedContext: ICompleteSharedContext, throwError?: boolean) {\n    this.expression = expr;\n    this.aggregator = new Aggregator(expr, new aggregators[<SetFunction> expr.aggregator](expr, sharedContext));\n    this.throwError = throwError || false;\n    this.isWildcard = expr.expression.expressionType === Algebra.expressionTypes.WILDCARD;\n    if (this.isWildcard) {\n      this.wildcardAggregator = new WildcardCountAggregator(expr);\n    }\n  }\n\n  /**\n   * The spec says to throw an error when a set function is called on an empty\n   * set (unless explicitly mentioned otherwise like COUNT).\n   * However, aggregate error handling says to not bind the result in case of an\n   * error. So to simplify logic in the caller, we return undefined by default.\n   *\n   * @param throwError whether this function should respect the spec and throw an error if no empty value is defined\n   */\n  public static emptyValue(expr: Algebra.AggregateExpression, throwError = false): RDF.Term | undefined {\n    let val: RDF.Term | undefined;\n    if (expr.expression.expressionType === Algebra.expressionTypes.WILDCARD) {\n      val = WildcardCountAggregator.emptyValue();\n    } else {\n      val = Aggregator.emptyValue(aggregators[<SetFunction> expr.aggregator]);\n    }\n    if (val === undefined && throwError) {\n      throw new Err.EmptyAggregateError();\n    }\n    return val;\n  }\n\n  public result(): RDF.Term | undefined {\n    if (this.errorOccurred) {\n      return undefined;\n    }\n    if (this.isWildcard) {\n      return this.wildcardAggregator!.result();\n    }\n    return this.aggregator.result();\n  }\n\n  /**\n   * Put a binding from the result stream in the aggregate state.\n   *\n   * If any binding evaluation errors, the corresponding aggregate variable should be unbound.\n   * If this happens, calling @see result() will return @constant undefined\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n  abstract put(bindings: RDF.Bindings): void | Promise<void>;\n\n  protected abstract safeThrow(err: unknown): void;\n}\n"]}
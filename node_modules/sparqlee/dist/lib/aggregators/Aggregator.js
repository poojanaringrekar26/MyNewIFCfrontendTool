"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Aggregator = exports.AggregatorComponent = void 0;
const RdfString = require("rdf-string");
const TermTransformer_1 = require("../transformers/TermTransformer");
const Consts_1 = require("../util/Consts");
const TypeHandling_1 = require("../util/TypeHandling");
class AggregatorComponent {
    constructor(expr, sharedContext) {
        this.sharedContext = sharedContext;
        this.separator = expr.separator || ' ';
        this.termTransformer = new TermTransformer_1.TermTransformer(sharedContext.superTypeProvider);
    }
    static emptyValue() {
        return undefined;
    }
    termToNumericOrError(term) {
        if (term.termType !== 'Literal') {
            throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a numeric literal`);
        }
        else if (!(0, TypeHandling_1.isSubTypeOf)(term.datatype.value, Consts_1.TypeAlias.SPARQL_NUMERIC, this.sharedContext.superTypeProvider)) {
            throw new Error(`Term datatype ${term.datatype.value} with value ${term.value} has type ${term.termType} and is not a numeric literal`);
        }
        return this.termTransformer.transformLiteral(term);
    }
    extractValue(term) {
        if (term.termType !== 'Literal') {
            throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a literal`);
        }
        const transformedLit = this.termTransformer.transformLiteral(term);
        return { type: transformedLit.dataType, value: transformedLit.typedValue };
    }
}
exports.AggregatorComponent = AggregatorComponent;
/**
 * A base aggregator that can handle distinct and possibly wildcards.
 */
class Aggregator {
    constructor(expr, aggregatorComponent) {
        this.aggregatorComponent = aggregatorComponent;
        this.variableValues = new Map();
        this.distinct = expr.distinct;
    }
    static emptyValue(component) {
        return component.emptyValue();
    }
    result() {
        return this.aggregatorComponent.result();
    }
    put(bindings, variable = '') {
        if (!this.canSkip(bindings, variable)) {
            this.aggregatorComponent.put(bindings);
            this.addSeen(bindings, variable);
        }
    }
    canSkip(term, variable) {
        const set = this.variableValues.get(variable);
        return this.distinct && !!set && set.has(RdfString.termToString(term));
    }
    addSeen(term, variable) {
        if (this.distinct) {
            if (!this.variableValues.has(variable)) {
                this.variableValues.set(variable, new Set());
            }
            this.variableValues.get(variable).add(RdfString.termToString(term));
        }
    }
}
exports.Aggregator = Aggregator;
//# sourceMappingURL=Aggregator.js.map
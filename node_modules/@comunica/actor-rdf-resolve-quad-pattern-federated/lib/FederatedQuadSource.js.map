{"version":3,"file":"FederatedQuadSource.js","sourceRoot":"","sources":["FederatedQuadSource.ts"],"names":[],"mappings":"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","sourcesContent":["import { ClosableTransformIterator } from '@comunica/bus-query-operation';\nimport type { MediatorRdfMetadataAccumulate } from '@comunica/bus-rdf-metadata-accumulate';\nimport type {\n  IActorRdfResolveQuadPatternOutput,\n  IQuadSource,\n  MediatorRdfResolveQuadPattern,\n} from '@comunica/bus-rdf-resolve-quad-pattern';\nimport { getDataSourceContext } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport { KeysRdfResolveQuadPattern } from '@comunica/context-entries';\nimport { BlankNodeScoped } from '@comunica/data-factory';\nimport { MetadataValidationState } from '@comunica/metadata';\nimport type { IActionContext, DataSources, IDataSource, MetadataQuads } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { ArrayIterator, UnionIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport { mapTerms } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory } from 'sparqlalgebrajs';\n\nconst DF = new DataFactory();\n\n/**\n * A FederatedQuadSource can evaluate quad pattern queries over the union of different heterogeneous sources.\n * It will call the given mediator to evaluate each quad pattern query separately.\n */\nexport class FederatedQuadSource implements IQuadSource {\n  private static readonly SKOLEM_PREFIX = 'urn:comunica_skolem:source_';\n\n  protected readonly mediatorResolveQuadPattern: MediatorRdfResolveQuadPattern;\n  protected readonly mediatorRdfMetadataAccumulate: MediatorRdfMetadataAccumulate;\n\n  protected readonly sources: DataSources;\n  protected readonly contextDefault: IActionContext;\n  protected readonly emptyPatterns: Map<IDataSource, RDF.BaseQuad[]>;\n  protected readonly sourceIds: Map<IDataSource, string>;\n  protected readonly skipEmptyPatterns: boolean;\n  protected readonly algebraFactory: Factory;\n\n  public constructor(\n    mediatorResolveQuadPattern: MediatorRdfResolveQuadPattern,\n    mediatorRdfMetadataAccumulate: MediatorRdfMetadataAccumulate,\n    context: IActionContext,\n    emptyPatterns: Map<IDataSource, RDF.Quad[]>,\n    skipEmptyPatterns: boolean,\n  ) {\n    this.mediatorResolveQuadPattern = mediatorResolveQuadPattern;\n    this.mediatorRdfMetadataAccumulate = mediatorRdfMetadataAccumulate;\n    this.sources = context.get(KeysRdfResolveQuadPattern.sources)!;\n    this.contextDefault = context.delete(KeysRdfResolveQuadPattern.sources);\n    this.emptyPatterns = emptyPatterns;\n    this.sourceIds = context.get(KeysRdfResolveQuadPattern.sourceIds) ?? new Map();\n    this.skipEmptyPatterns = skipEmptyPatterns;\n    this.algebraFactory = new Factory();\n\n    // Initialize sources in the emptyPatterns datastructure\n    if (this.skipEmptyPatterns) {\n      for (const source of this.sources) {\n        if (!this.emptyPatterns.has(source)) {\n          this.emptyPatterns.set(source, []);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if the given RDF term is not bound to an exact value.\n   * I.e., if it is not a Variable.\n   * @param {RDF.Term} term An RDF term.\n   * @return {boolean} If it is not bound.\n   */\n  public static isTermBound(term: RDF.Term): boolean {\n    return term.termType !== 'Variable';\n  }\n\n  /**\n   * Checks if the given (child) pattern is a more bound version of the given (parent) pattern.\n   * This will also return true if the patterns are equal.\n   * @param {RDF.BaseQuad} child A child pattern.\n   * @param {RDF.BaseQuad} parent A parent pattern.\n   * @return {boolean} If child is a sub-pattern of parent\n   */\n  public static isSubPatternOf(child: RDF.BaseQuad, parent: RDF.BaseQuad): boolean {\n    return (!FederatedQuadSource.isTermBound(parent.subject) || parent.subject.equals(child.subject)) &&\n      (!FederatedQuadSource.isTermBound(parent.predicate) || parent.predicate.equals(child.predicate)) &&\n      (!FederatedQuadSource.isTermBound(parent.object) || parent.object.equals(child.object)) &&\n      (!FederatedQuadSource.isTermBound(parent.graph) || parent.graph.equals(child.graph));\n  }\n\n  /**\n   * If the given term is a blank node, return a deterministic named node for it\n   * based on the source id and the blank node value.\n   * @param term Any RDF term.\n   * @param sourceId A source identifier.\n   * @return If the given term was a blank node, this will return a skolemized named node, otherwise the original term.\n   */\n  public static skolemizeTerm(term: RDF.Term, sourceId: string): RDF.Term | BlankNodeScoped {\n    if (term.termType === 'BlankNode') {\n      return new BlankNodeScoped(`bc_${sourceId}_${term.value}`,\n        DF.namedNode(`${FederatedQuadSource.SKOLEM_PREFIX}${sourceId}:${term.value}`));\n    }\n    return term;\n  }\n\n  /**\n   * Skolemize all terms in the given quad.\n   * @param quad An RDF quad.\n   * @param sourceId A source identifier.\n   * @return The skolemized quad.\n   */\n  public static skolemizeQuad<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q, sourceId: string): Q {\n    return mapTerms(quad, term => FederatedQuadSource.skolemizeTerm(term, sourceId));\n  }\n\n  /**\n   * If a given term was a skolemized named node for the given source id,\n   * deskolemize it again to a blank node.\n   * If the given term was a skolemized named node for another source, return false.\n   * If the given term was not a skolemized named node, return the original term.\n   * @param term Any RDF term.\n   * @param sourceId A source identifier.\n   */\n  public static deskolemizeTerm(term: RDF.Term, sourceId: string): RDF.Term | null {\n    if (term.termType === 'BlankNode' && 'skolemized' in term) {\n      term = (<BlankNodeScoped> term).skolemized;\n    }\n    if (term.termType === 'NamedNode' && term.value.startsWith(FederatedQuadSource.SKOLEM_PREFIX)) {\n      const colonSeparator = term.value.indexOf(':', FederatedQuadSource.SKOLEM_PREFIX.length);\n      const termSourceId = term.value.slice(FederatedQuadSource.SKOLEM_PREFIX.length, colonSeparator);\n      // We had a skolemized term\n      if (termSourceId === sourceId) {\n        // It came from the correct source\n        const termLabel = term.value.slice(colonSeparator + 1, term.value.length);\n        return DF.blankNode(termLabel);\n      }\n      // It came from a different source\n      return null;\n    }\n    return term;\n  }\n\n  /**\n   * Deskolemize all terms in the given quad.\n   * @param quad An RDF quad.\n   * @param sourceId A source identifier.\n   * @return The deskolemized quad.\n   */\n  public static deskolemizeQuad<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q, sourceId: string): Q {\n    return mapTerms(quad, (term: RDF.Term): RDF.Term => {\n      const newTerm = FederatedQuadSource.deskolemizeTerm(term, sourceId);\n      // If the term was skolemized in a different source then dont deskolemize it\n      return !newTerm ? term : newTerm;\n    });\n  }\n\n  /**\n   * If the given source is guaranteed to produce an empty result for the given pattern.\n   *\n   * This prediction is done based on the 'emptyPatterns' datastructure that is stored within this actor.\n   * Every time an empty pattern is passed, this pattern is stored in this datastructure for this source.\n   * If this pattern (or a more bound pattern) is queried, we know for certain that it will be empty again.\n   * This is under the assumption that sources will remain static during query evaluation.\n   *\n   * @param {IQuerySource} source\n   * @param {RDF.BaseQuad} pattern\n   * @return {boolean}\n   */\n  public isSourceEmpty(source: IDataSource, pattern: RDF.BaseQuad): boolean {\n    if (!this.skipEmptyPatterns) {\n      return false;\n    }\n    const emptyPatterns: RDF.BaseQuad[] | undefined = this.emptyPatterns.get(source);\n    if (emptyPatterns) {\n      for (const emptyPattern of emptyPatterns) {\n        if (FederatedQuadSource.isSubPatternOf(pattern, emptyPattern)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get the unique, deterministic id for the given source.\n   * @param source A data source.\n   * @return The id of the given source.\n   */\n  public getSourceId(source: IDataSource): string {\n    let sourceId = this.sourceIds.get(source);\n    if (sourceId === undefined) {\n      sourceId = `${this.sourceIds.size}`;\n      this.sourceIds.set(source, sourceId);\n    }\n    return sourceId;\n  }\n\n  public match(subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph: RDF.Term): AsyncIterator<RDF.Quad> {\n    // A function that is called every time metadata is found,\n    // and will accumulate all metadata if the metadata from all sources have been defined.\n    const tryAccumulatingMetadata = async(): Promise<void> => {\n      // Only accumulate when the metadata of all sources have been defined\n      if (accumulatingMetadata.size === this.sources.length) {\n        // Accumulate metadata using mediator\n        let accumulatedMetadata: MetadataQuads = <MetadataQuads> (await this.mediatorRdfMetadataAccumulate\n          .mediate({ mode: 'initialize', context: this.contextDefault })).metadata;\n        for (const appendingMetadata of accumulatingMetadata.values()) {\n          accumulatedMetadata = {\n            ...appendingMetadata,\n            ...(await this.mediatorRdfMetadataAccumulate\n              .mediate({\n                mode: 'append',\n                accumulatedMetadata,\n                appendingMetadata,\n                context: this.contextDefault,\n              })).metadata,\n          };\n        }\n        // Create new metadata state\n        accumulatedMetadata.state = new MetadataValidationState();\n\n        // Emit metadata, and invalidate any metadata that was set before\n        const metadataToInvalidate = it.getProperty<MetadataQuads>('metadata');\n        it.setProperty('metadata', accumulatedMetadata);\n        metadataToInvalidate?.state.invalidate();\n      }\n    };\n\n    // Immediately start sub-iterators for each source, so that their metadata can be collected.\n    const accumulatingMetadata: Map<string, MetadataQuads> = new Map();\n    const proxyIt: Promise<AsyncIterator<RDF.Quad>[]> = Promise.all(this.sources.map(async(source, sourceIndex) => {\n      const sourceId = this.getSourceId(source);\n\n      // Deskolemize terms, so we send the original blank nodes to each source.\n      // Note that some sources may not match bnodes by label. SPARQL endpoints for example consider them variables.\n      const patternS = FederatedQuadSource.deskolemizeTerm(subject, sourceId);\n      const patternP = FederatedQuadSource.deskolemizeTerm(predicate, sourceId);\n      const patternO = FederatedQuadSource.deskolemizeTerm(object, sourceId);\n      const patternG = FederatedQuadSource.deskolemizeTerm(graph, sourceId);\n      let pattern: Algebra.Pattern | undefined;\n\n      // Prepare the context for this specific source\n      let context: IActionContext = getDataSourceContext(source, this.contextDefault);\n\n      context = context.set(KeysRdfResolveQuadPattern.source, source);\n\n      let output: IActorRdfResolveQuadPatternOutput;\n      // If any of the deskolemized blank nodes originate from another source,\n      // or if we can predict that the given source will have no bindings for the given pattern,\n      // return an empty iterator.\n      if (!patternS || !patternP || !patternO || !patternG ||\n        // eslint-disable-next-line no-cond-assign\n        this.isSourceEmpty(source, pattern = this.algebraFactory\n          .createPattern(patternS, patternP, patternO, patternG))) {\n        output = { data: new ArrayIterator([], { autoStart: false }) };\n        // Return the default metadata\n        output.data.setProperty('metadata', {\n          state: new MetadataValidationState(),\n          ...(await this.mediatorRdfMetadataAccumulate\n            .mediate({ mode: 'initialize', context: this.contextDefault })).metadata,\n        });\n      } else {\n        output = await this.mediatorResolveQuadPattern.mediate({ pattern, context });\n      }\n\n      // Handle the metadata from this source\n      const addMetadataPropertyListener = (): void => {\n        output.data.getProperty('metadata', (subMetadata: MetadataQuads) => {\n          accumulatingMetadata.set(`${sourceIndex}`, subMetadata);\n\n          // Save empty patterns\n          if (this.skipEmptyPatterns &&\n            !subMetadata.cardinality?.value &&\n            pattern &&\n            !this.isSourceEmpty(source, pattern)) {\n            this.emptyPatterns.get(source)!.push(pattern);\n          }\n\n          // Accumulate metadata\n          tryAccumulatingMetadata()\n            .catch(error => it.emit('error', error));\n\n          // Re-accumulate metadata if this metadata changes\n          subMetadata.state?.addInvalidateListener(() => {\n            // Remove this source's metadata in the array\n            accumulatingMetadata.delete(`${sourceIndex}`);\n\n            // Listen to new metadata property changes\n            addMetadataPropertyListener();\n          });\n        });\n      };\n      addMetadataPropertyListener();\n\n      // Determine the data stream from this source\n      const data = output.data.map(quad => FederatedQuadSource.skolemizeQuad(quad, sourceId));\n\n      // Forward errors to our final iterator\n      data.on('error', error => it.emit('error', error));\n\n      return data;\n    }));\n\n    // Forward any source creation rejections as errors to our final iterator\n    proxyIt.catch(error => it.emit('error', error));\n\n    // Take the union of all source streams\n    const it = new ClosableTransformIterator(async() => new UnionIterator(await proxyIt), {\n      autoStart: false,\n      onClose() {\n        // Destroy the sub-iterators\n        proxyIt.then(proxyItResolved => {\n          for (const subIt of proxyItResolved) {\n            subIt.destroy();\n          }\n        }, () => {\n          // Void errors\n        });\n      },\n    });\n\n    // If we have 0 sources, immediately emit metadata\n    if (this.sources.length === 0) {\n      this.mediatorRdfMetadataAccumulate\n        .mediate({ mode: 'initialize', context: this.contextDefault })\n        .then(result => it.setProperty('metadata', { state: new MetadataValidationState(), ...result.metadata }))\n        .catch(error => it.emit('error', error));\n    }\n\n    return it;\n  }\n}\n"]}
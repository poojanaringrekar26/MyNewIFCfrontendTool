"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorRdfResolveQuadPatternFederated = void 0;
const bus_rdf_resolve_quad_pattern_1 = require("@comunica/bus-rdf-resolve-quad-pattern");
const FederatedQuadSource_1 = require("./FederatedQuadSource");
/**
 * A comunica Federated RDF Resolve Quad Pattern Actor.
 */
class ActorRdfResolveQuadPatternFederated extends bus_rdf_resolve_quad_pattern_1.ActorRdfResolveQuadPatternSource {
    constructor(args) {
        super(args);
        this.emptyPatterns = new Map();
        // TODO: remove this backwards-compatibility in the next major version, and make the param mandatory
        if (!args.mediatorRdfMetadataAccumulate) {
            this.mediatorRdfMetadataAccumulate = {
                async mediate(action) {
                    if (action.mode === 'initialize') {
                        return { metadata: { cardinality: { type: 'exact', value: 0 }, canContainUndefs: false } };
                    }
                    const metadata = { ...action.accumulatedMetadata };
                    const subMetadata = action.appendingMetadata;
                    if (!subMetadata.cardinality || !Number.isFinite(subMetadata.cardinality.value)) {
                        // We're already at infinite, so ignore any later metadata
                        metadata.cardinality.type = 'estimate';
                        metadata.cardinality.value = Number.POSITIVE_INFINITY;
                    }
                    else {
                        if (subMetadata.cardinality.type === 'estimate') {
                            metadata.cardinality.type = 'estimate';
                        }
                        metadata.cardinality.value += subMetadata.cardinality.value;
                    }
                    if (metadata.requestTime || subMetadata.requestTime) {
                        metadata.requestTime = metadata.requestTime || 0;
                        subMetadata.requestTime = subMetadata.requestTime || 0;
                        metadata.requestTime += subMetadata.requestTime;
                    }
                    if (metadata.pageSize || subMetadata.pageSize) {
                        metadata.pageSize = metadata.pageSize || 0;
                        subMetadata.pageSize = subMetadata.pageSize || 0;
                        metadata.pageSize += subMetadata.pageSize;
                    }
                    if (subMetadata.canContainUndefs) {
                        metadata.canContainUndefs = true;
                    }
                    return { metadata };
                },
            };
        }
    }
    async test(action) {
        const sources = (0, bus_rdf_resolve_quad_pattern_1.getContextSources)(action.context);
        if (!sources) {
            throw new Error(`Actor ${this.name} can only resolve quad pattern queries against a sources array.`);
        }
        return true;
    }
    async getSource(context) {
        return new FederatedQuadSource_1.FederatedQuadSource(this.mediatorResolveQuadPattern, this.mediatorRdfMetadataAccumulate, context, this.emptyPatterns, this.skipEmptyPatterns);
    }
}
exports.ActorRdfResolveQuadPatternFederated = ActorRdfResolveQuadPatternFederated;
//# sourceMappingURL=ActorRdfResolveQuadPatternFederated.js.map
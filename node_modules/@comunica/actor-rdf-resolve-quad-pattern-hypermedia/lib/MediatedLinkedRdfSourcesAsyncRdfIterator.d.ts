import type { MediatorDereferenceRdf } from '@comunica/bus-dereference-rdf';
import type { MediatorRdfMetadata } from '@comunica/bus-rdf-metadata';
import type { MediatorRdfMetadataAccumulate } from '@comunica/bus-rdf-metadata-accumulate';
import type { MediatorRdfMetadataExtract } from '@comunica/bus-rdf-metadata-extract';
import type { MediatorRdfResolveHypermedia } from '@comunica/bus-rdf-resolve-hypermedia';
import type { ILink, MediatorRdfResolveHypermediaLinks } from '@comunica/bus-rdf-resolve-hypermedia-links';
import type { ILinkQueue, MediatorRdfResolveHypermediaLinksQueue } from '@comunica/bus-rdf-resolve-hypermedia-links-queue';
import type { IActionContext, IAggregatedStore, MetadataQuads } from '@comunica/types';
import type * as RDF from '@rdfjs/types';
import type { ISourceState } from './LinkedRdfSourcesAsyncRdfIterator';
import { LinkedRdfSourcesAsyncRdfIterator } from './LinkedRdfSourcesAsyncRdfIterator';
/**
 * An quad iterator that can iterate over consecutive RDF sources
 * that are determined using the rdf-resolve-hypermedia-links bus.
 *
 * @see LinkedRdfSourcesAsyncRdfIterator
 */
export declare class MediatedLinkedRdfSourcesAsyncRdfIterator extends LinkedRdfSourcesAsyncRdfIterator {
    private readonly mediatorDereferenceRdf;
    private readonly mediatorMetadata;
    private readonly mediatorMetadataExtract;
    private readonly mediatorMetadataAccumulate;
    private readonly mediatorRdfResolveHypermedia;
    private readonly mediatorRdfResolveHypermediaLinks;
    private readonly mediatorRdfResolveHypermediaLinksQueue;
    private readonly context;
    private readonly forceSourceType?;
    private readonly handledUrls;
    private readonly aggregatedStore;
    private linkQueue;
    private wasForcefullyClosed;
    constructor(cacheSize: number, context: IActionContext, forceSourceType: string | undefined, subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph: RDF.Term, firstUrl: string, maxIterators: number, aggregatedStore: IAggregatedStore | undefined, mediators: IMediatorArgs);
    close(): void;
    destroy(cause?: Error): void;
    protected isCloseable(linkQueue: ILinkQueue): boolean;
    protected canStartNewIterator(): boolean;
    protected isRunning(): boolean;
    protected shouldStoreSourcesStates(): boolean;
    getLinkQueue(): Promise<ILinkQueue>;
    protected getSourceLinks(metadata: Record<string, any>): Promise<ILink[]>;
    protected getSource(link: ILink, handledDatasets: Record<string, boolean>): Promise<ISourceState>;
    accumulateMetadata(accumulatedMetadata: MetadataQuads, appendingMetadata: MetadataQuads): Promise<MetadataQuads>;
    protected updateMetadata(metadataNew: MetadataQuads): void;
}
export interface IMediatorArgs {
    mediatorDereferenceRdf: MediatorDereferenceRdf;
    mediatorMetadata: MediatorRdfMetadata;
    mediatorMetadataExtract: MediatorRdfMetadataExtract;
    mediatorMetadataAccumulate: MediatorRdfMetadataAccumulate;
    mediatorRdfResolveHypermedia: MediatorRdfResolveHypermedia;
    mediatorRdfResolveHypermediaLinks: MediatorRdfResolveHypermediaLinks;
    mediatorRdfResolveHypermediaLinksQueue: MediatorRdfResolveHypermediaLinksQueue;
}

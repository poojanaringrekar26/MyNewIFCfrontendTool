{"version":3,"file":"MediatedLinkedRdfSourcesAsyncRdfIterator.js","sourceRoot":"","sources":["MediatedLinkedRdfSourcesAsyncRdfIterator.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActorDereferenceRdfOutput, MediatorDereferenceRdf } from '@comunica/bus-dereference-rdf';\nimport type { IActorRdfMetadataOutput, MediatorRdfMetadata } from '@comunica/bus-rdf-metadata';\nimport type { MediatorRdfMetadataAccumulate } from '@comunica/bus-rdf-metadata-accumulate';\nimport type { MediatorRdfMetadataExtract } from '@comunica/bus-rdf-metadata-extract';\nimport type { MediatorRdfResolveHypermedia } from '@comunica/bus-rdf-resolve-hypermedia';\nimport type { ILink,\n  MediatorRdfResolveHypermediaLinks } from '@comunica/bus-rdf-resolve-hypermedia-links';\nimport type { ILinkQueue,\n  MediatorRdfResolveHypermediaLinksQueue } from '@comunica/bus-rdf-resolve-hypermedia-links-queue';\nimport type { IActionContext, IAggregatedStore, MetadataQuads } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { Readable } from 'readable-stream';\nimport type { ISourceState } from './LinkedRdfSourcesAsyncRdfIterator';\nimport { LinkedRdfSourcesAsyncRdfIterator } from './LinkedRdfSourcesAsyncRdfIterator';\n\n/**\n * An quad iterator that can iterate over consecutive RDF sources\n * that are determined using the rdf-resolve-hypermedia-links bus.\n *\n * @see LinkedRdfSourcesAsyncRdfIterator\n */\nexport class MediatedLinkedRdfSourcesAsyncRdfIterator extends LinkedRdfSourcesAsyncRdfIterator {\n  private readonly mediatorDereferenceRdf: MediatorDereferenceRdf;\n  private readonly mediatorMetadata: MediatorRdfMetadata;\n  private readonly mediatorMetadataExtract: MediatorRdfMetadataExtract;\n  private readonly mediatorMetadataAccumulate: MediatorRdfMetadataAccumulate;\n  private readonly mediatorRdfResolveHypermedia: MediatorRdfResolveHypermedia;\n  private readonly mediatorRdfResolveHypermediaLinks: MediatorRdfResolveHypermediaLinks;\n  private readonly mediatorRdfResolveHypermediaLinksQueue: MediatorRdfResolveHypermediaLinksQueue;\n  private readonly context: IActionContext;\n  private readonly forceSourceType?: string;\n  private readonly handledUrls: Record<string, boolean>;\n  private readonly aggregatedStore: IAggregatedStore | undefined;\n  private linkQueue: Promise<ILinkQueue> | undefined;\n  private wasForcefullyClosed = false;\n\n  public constructor(cacheSize: number, context: IActionContext, forceSourceType: string | undefined,\n    subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph: RDF.Term,\n    firstUrl: string, maxIterators: number, aggregatedStore: IAggregatedStore | undefined,\n    mediators: IMediatorArgs) {\n    super(\n      cacheSize,\n      subject,\n      predicate,\n      object,\n      graph,\n      firstUrl,\n      maxIterators,\n      // Buffersize must be infinite for an aggregated store because it must keep filling until there are no more\n      // derived iterators in the aggregated store.\n      aggregatedStore ? { maxBufferSize: Number.POSITIVE_INFINITY } : undefined,\n    );\n    this.context = context;\n    this.forceSourceType = forceSourceType;\n    this.mediatorDereferenceRdf = mediators.mediatorDereferenceRdf;\n    this.mediatorMetadata = mediators.mediatorMetadata;\n    this.mediatorMetadataExtract = mediators.mediatorMetadataExtract;\n    this.mediatorMetadataAccumulate = mediators.mediatorMetadataAccumulate;\n    this.mediatorRdfResolveHypermedia = mediators.mediatorRdfResolveHypermedia;\n    this.mediatorRdfResolveHypermediaLinks = mediators.mediatorRdfResolveHypermediaLinks;\n    this.mediatorRdfResolveHypermediaLinksQueue = mediators.mediatorRdfResolveHypermediaLinksQueue;\n    this.handledUrls = { [firstUrl]: true };\n    this.aggregatedStore = aggregatedStore;\n  }\n\n  // Mark the aggregated store as ended once we trigger the closing or destroying of this iterator.\n  // We don't override _end, because that would mean that we have to wait\n  // until the buffer of this iterator must be fully consumed, which will not always be the case.\n\n  public close(): void {\n    this.getLinkQueue()\n      .then(linkQueue => {\n        if (this.isCloseable(linkQueue)) {\n          this.aggregatedStore?.end();\n          super.close();\n        } else {\n          this.wasForcefullyClosed = true;\n        }\n      })\n      .catch(error => super.destroy(error));\n  }\n\n  public destroy(cause?: Error): void {\n    this.getLinkQueue()\n      .then(linkQueue => {\n        if (this.isCloseable(linkQueue)) {\n          this.aggregatedStore?.end();\n          super.destroy(cause);\n        } else {\n          this.wasForcefullyClosed = true;\n        }\n      })\n      .catch(error => super.destroy(error));\n  }\n\n  protected isCloseable(linkQueue: ILinkQueue): boolean {\n    return (this.wasForcefullyClosed || linkQueue.isEmpty()) && !this.areIteratorsRunning();\n  }\n\n  protected override canStartNewIterator(): boolean {\n    // Also allow sub-iterators to be started if the aggregated store has at least one running iterator.\n    // We need this because there are cases where these running iterators will be consumed before this linked iterator.\n    return !this.wasForcefullyClosed &&\n      (this.aggregatedStore && this.aggregatedStore.hasRunningIterators()) || super.canStartNewIterator();\n  }\n\n  protected override isRunning(): boolean {\n    // Same as above\n    return (this.aggregatedStore && this.aggregatedStore.hasRunningIterators()) || !this.done;\n  }\n\n  protected shouldStoreSourcesStates(): boolean {\n    return this.aggregatedStore === undefined;\n  }\n\n  public getLinkQueue(): Promise<ILinkQueue> {\n    if (!this.linkQueue) {\n      this.linkQueue = this.mediatorRdfResolveHypermediaLinksQueue\n        .mediate({ firstUrl: this.firstUrl, context: this.context })\n        .then(result => result.linkQueue);\n    }\n    return this.linkQueue;\n  }\n\n  protected async getSourceLinks(metadata: Record<string, any>): Promise<ILink[]> {\n    try {\n      const { links } = await this.mediatorRdfResolveHypermediaLinks.mediate({ context: this.context, metadata });\n\n      // Filter URLs to avoid cyclic next-page loops\n      return links.filter(link => {\n        if (this.handledUrls[link.url]) {\n          return false;\n        }\n        this.handledUrls[link.url] = true;\n        return true;\n      });\n    } catch {\n      // No next URLs may be available, for example when we've reached the end of a Hydra next-page sequence.\n      return [];\n    }\n  }\n\n  protected async getSource(link: ILink, handledDatasets: Record<string, boolean>): Promise<ISourceState> {\n    // Include context entries from link\n    let context = this.context;\n    if (link.context) {\n      context = context.merge(link.context);\n    }\n\n    // Get the RDF representation of the given document\n    let url = link.url;\n    let quads: RDF.Stream;\n    let metadata: Record<string, any>;\n    try {\n      const dereferenceRdfOutput: IActorDereferenceRdfOutput = await this.mediatorDereferenceRdf\n        .mediate({ context, url });\n      url = dereferenceRdfOutput.url;\n\n      // Determine the metadata\n      const rdfMetadataOutput: IActorRdfMetadataOutput = await this.mediatorMetadata.mediate(\n        { context, url, quads: dereferenceRdfOutput.data, triples: dereferenceRdfOutput.metadata?.triples },\n      );\n\n      rdfMetadataOutput.data.on('error', () => {\n        // Silence errors in the data stream,\n        // as they will be emitted again in the metadata stream,\n        // and will result in a promise rejection anyways.\n        // If we don't do this, we end up with an unhandled error message\n      });\n\n      metadata = (await this.mediatorMetadataExtract.mediate({\n        context,\n        url,\n        // The problem appears to be conflicting metadata keys here\n        metadata: rdfMetadataOutput.metadata,\n        headers: dereferenceRdfOutput.headers,\n        requestTime: dereferenceRdfOutput.requestTime,\n      })).metadata;\n      quads = rdfMetadataOutput.data;\n\n      // Optionally filter the resulting data\n      if (link.transform) {\n        quads = await link.transform(quads);\n      }\n    } catch (error: unknown) {\n      // Make sure that dereference errors are only emitted once an actor really needs the read quads\n      // This for example allows SPARQL endpoints that error on service description fetching to still be source-forcible\n      quads = new Readable();\n      quads.read = () => {\n        setTimeout(() => quads.emit('error', error));\n        return null;\n      };\n      metadata = {};\n    }\n\n    // Aggregate all discovered quads into a store.\n    this.aggregatedStore?.setBaseMetadata(<MetadataQuads> metadata, false);\n    this.aggregatedStore?.import(quads);\n\n    // Determine the source\n    const { source, dataset } = await this.mediatorRdfResolveHypermedia.mediate({\n      context,\n      forceSourceType: this.forceSourceType,\n      handledDatasets,\n      metadata,\n      quads,\n      url,\n    });\n\n    if (dataset) {\n      // Mark the dataset as applied\n      // This is needed to make sure that things like QPF search forms are only applied once,\n      // and next page links are followed after that.\n      handledDatasets[dataset] = true;\n    }\n\n    return { link, source, metadata: <MetadataQuads> metadata, handledDatasets };\n  }\n\n  public async accumulateMetadata(\n    accumulatedMetadata: MetadataQuads,\n    appendingMetadata: MetadataQuads,\n  ): Promise<MetadataQuads> {\n    return <MetadataQuads> (await this.mediatorMetadataAccumulate.mediate({\n      mode: 'append',\n      accumulatedMetadata,\n      appendingMetadata,\n      context: this.context,\n    })).metadata;\n  }\n\n  protected updateMetadata(metadataNew: MetadataQuads): void {\n    super.updateMetadata(metadataNew);\n    this.aggregatedStore?.setBaseMetadata(metadataNew, true);\n  }\n}\n\nexport interface IMediatorArgs {\n  mediatorDereferenceRdf: MediatorDereferenceRdf;\n  mediatorMetadata: MediatorRdfMetadata;\n  mediatorMetadataExtract: MediatorRdfMetadataExtract;\n  mediatorMetadataAccumulate: MediatorRdfMetadataAccumulate;\n  mediatorRdfResolveHypermedia: MediatorRdfResolveHypermedia;\n  mediatorRdfResolveHypermediaLinks: MediatorRdfResolveHypermediaLinks;\n  mediatorRdfResolveHypermediaLinksQueue: MediatorRdfResolveHypermediaLinksQueue;\n}\n"]}
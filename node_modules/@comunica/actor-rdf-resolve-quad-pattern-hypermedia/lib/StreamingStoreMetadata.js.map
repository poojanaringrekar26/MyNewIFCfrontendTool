{"version":3,"file":"StreamingStoreMetadata.js","sourceRoot":"","sources":["StreamingStoreMetadata.ts"],"names":[],"mappings":"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","sourcesContent":["// eslint-disable-next-line import/no-nodejs-modules\nimport type { EventEmitter } from 'events';\nimport { ClosableTransformIterator } from '@comunica/bus-query-operation';\nimport { MetadataValidationState } from '@comunica/metadata';\nimport type { MetadataQuads, IAggregatedStore } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { StreamingStore } from 'rdf-streaming-store';\n\n/**\n * A StreamingStore that returns an AsyncIterator with a valid MetadataQuads property.\n */\nexport class StreamingStoreMetadata extends StreamingStore implements IAggregatedStore {\n  public started = false;\n  public readonly runningIterators: Set<AsyncIterator<RDF.Quad>> = new Set<AsyncIterator<RDF.Quad>>();\n  protected readonly metadataAccumulator:\n  (accumulatedMetadata: MetadataQuads, appendingMetadata: MetadataQuads) => Promise<MetadataQuads>;\n\n  protected baseMetadata: MetadataQuads = {\n    state: new MetadataValidationState(),\n    cardinality: { type: 'exact', value: 0 },\n    canContainUndefs: false,\n  };\n\n  public constructor(\n    store: RDF.Store | undefined,\n    metadataAccumulator:\n    (accumulatedMetadata: MetadataQuads, appendingMetadata: MetadataQuads) => Promise<MetadataQuads>,\n  ) {\n    super(store);\n    this.metadataAccumulator = metadataAccumulator;\n  }\n\n  public import(stream: RDF.Stream): EventEmitter {\n    if (!this.ended) {\n      super.import(stream);\n    }\n    return stream;\n  }\n\n  public hasRunningIterators(): boolean {\n    return this.runningIterators.size > 0;\n  }\n\n  public match(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): AsyncIterator<RDF.Quad> {\n    // Wrap the raw stream in an AsyncIterator\n    const rawStream = super.match(subject, predicate, object, graph);\n    const iterator = new ClosableTransformIterator<RDF.Quad, RDF.Quad>(\n      <any> rawStream, {\n        autoStart: false,\n        onClose: () => {\n          // Running iterators are deleted once closed or destroyed\n          this.runningIterators.delete(iterator);\n        },\n      },\n    );\n\n    // Expose the metadata property containing the cardinality\n    let count = this.getStore().countQuads(subject!, predicate!, object!, graph!);\n    const metadata: MetadataQuads = {\n      state: new MetadataValidationState(),\n      cardinality: {\n        type: 'estimate',\n        value: count,\n      },\n      canContainUndefs: false,\n    };\n    iterator.setProperty('metadata', metadata);\n    iterator.setProperty('lastCount', count);\n\n    // Ever time a new quad is pushed into the iterator, update the metadata\n    rawStream.on('quad', () => {\n      iterator.setProperty('lastCount', ++count);\n      this.updateMetadataState(iterator, count);\n    });\n\n    // Store all running iterators until they close or are destroyed\n    this.runningIterators.add(iterator);\n\n    return iterator;\n  }\n\n  public setBaseMetadata(metadata: MetadataQuads, updateStates: boolean): void {\n    this.baseMetadata = { ...metadata };\n    this.baseMetadata.cardinality = { type: 'exact', value: 0 };\n\n    if (updateStates) {\n      for (const iterator of this.runningIterators) {\n        const count: number = iterator.getProperty('lastCount')!;\n        this.updateMetadataState(iterator, count);\n      }\n    }\n  }\n\n  protected updateMetadataState(iterator: AsyncIterator<RDF.Quad>, count: number): void {\n    // Append the given cardinality to the base metadata\n    const metadataNew: MetadataQuads = {\n      state: new MetadataValidationState(),\n      cardinality: {\n        type: 'estimate',\n        value: count,\n      },\n      canContainUndefs: false,\n    };\n\n    this.metadataAccumulator(this.baseMetadata, metadataNew)\n      .then(accumulatedMetadata => {\n        accumulatedMetadata.state = new MetadataValidationState();\n\n        // Set the new metadata, and invalidate the previous state\n        const metadataToInvalidate = iterator.getProperty<MetadataQuads>('metadata');\n        iterator.setProperty('metadata', accumulatedMetadata);\n        metadataToInvalidate?.state.invalidate();\n      })\n      .catch(() => {\n        // Void errors\n      });\n  }\n}\n"]}